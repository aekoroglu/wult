#!/usr/bin/python3
#
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2019-2020 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

"""
wult - a tool for measuring C-state latency.
"""

import sys
import logging
from pathlib import Path

try:
    import argcomplete
except ImportError:
    # We can live without argcomplete, we only lose tab completions.
    argcomplete = None

from wultlibs.helperlibs import Logging, ArgParse, ReportID, Trivial, KernelVersion
from wultlibs.helperlibs.Exceptions import Error
from wultlibs import ToolsCommon, Devices, EventsProvider, RORawResult, WultHTMLReport
from wultlibs import WultRunner, WORawResult

VERSION = "1.8.10"
OWN_NAME = "wult"

# By default 'ReportID' module does not allow for the ":" character, but it is part of the PCI
# address, and we allow for PCI addresses as device IDs. Here are few constants that we use to
# extend the default allowed report ID characters set.
REPORTID_ADDITIONAL_CHARS = ":"
REPORTID_CHARS_DESCR = ReportID.get_charset_descr(additional_chars=REPORTID_ADDITIONAL_CHARS)

# Regular expressions for the datapoint CSV file columns names that should show up in the hover
# text of the scatter plot. The middle element selects all the core and package C-state residency
# columns.
HOVER_COLNAME_REGEXS = [".*Latency", ".*Delay", "LDist", "ReqCState", r"(Derived)?[PC]C.+%"]

LOG = logging.getLogger()
Logging.setup_logger(OWN_NAME)

def get_axes_default(name):
    """Returns the default CSV column names for X- or Y-axes, as well as histograms."""

    names = getattr(WultHTMLReport, f"DEFAULT_{name.upper()}")
    # The result is used for argparse, which does not accept '%' symbols.
    return names.replace("%", "%%")

def parse_arguments():
    """A helper function which parses the input arguments."""

    text = sys.modules[__name__].__doc__
    parser = ArgParse.ArgsParser(description=text, prog=OWN_NAME, ver=VERSION)

    text = "Force coloring of the text output."
    parser.add_argument("--force-color", action="store_true", help=text)
    subparsers = parser.add_subparsers(title="commands", metavar="")
    subparsers.required = True

    #
    # Create parsers for the "deploy" command.
    #
    text = f"Compile and deploy {OWN_NAME} drivers."
    descr = f"""Compile and deploy {OWN_NAME} drivers on local or remote host. This command has many
                options, but they are very rarely useful and most probably you do not need them."""
    subpars = subparsers.add_parser("deploy", help=text, description=descr)
    ToolsCommon.add_deploy_cmdline_args(subpars, "wult", drivers=True, helpers=False,
                                        argcomplete=argcomplete)
    subpars.set_defaults(func=ToolsCommon.deploy_command)

    #
    # Create parsers for the "scan" command.
    #
    text = "Scan for device id."
    descr = """Scan for compatible device."""
    subpars = subparsers.add_parser("scan", help=text, description=descr)
    subpars.set_defaults(func=scan_command)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    #
    # Create parsers for the "load" command.
    #
    text = f"Load {OWN_NAME} drivers and exit."
    descr = f"""Load {OWN_NAME} drivers and exit without starting the measurements."""
    subpars = subparsers.add_parser("load", help=text, description=descr)
    subpars.set_defaults(func=load_command)

    text = """This command exists for debugging and troubleshooting purposes. Please, do not use for
              other reasons. keep in mind that if the the specified \'devid\' device was bound to
              some driver (e.g., a network driver), it will be unbinded and with this option It
              won't be binded back."""

    subpars.add_argument("--no-unload", action="store_true", help=text)

    text = f"""By default {OWN_NAME} refuses to load network card drivers if its Linux network
               interface is in an active state, such as "up". Use '--force' to disable this safety
               mechanism. Use '--force' option with caution."""
    subpars.add_argument("--force", action="store_true", help=text)

    text = "The device ID, same as in the 'start' command."""
    subpars.add_argument("devid", help=text)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    #
    # Create parsers for the "start" command.
    #
    text = "Start the measurements."
    descr = """Start measuring and recording C-state latency."""
    subpars = subparsers.add_parser("start", help=text, description=descr)
    subpars.set_defaults(func=start_command)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    text = """How many datapoints should the test result include, default is 1000000. Note, in case
              a pre-existing test result is continued (see '--continue'), the pre-existing
              datapoints are taken into account. For example, if the test result already has 6000
              datapoints and '-c 100000' is used, the tool will collect 4000 datapoints and exit.
              Warning: collecting too many datapoints may result in a very large test result file,
              which will be difficult to process later, because that would require a lot of
              memory."""
    subpars.add_argument("-c", "--datapoints", default=1000000, metavar="COUNT", dest="dpcnt",
                         help=text)

    text = """If the output directory already contains the datapoints CSV file, do not override it
              (default behavior), but continue appending more datapoints instead."""
    subpars.add_argument("--continue", dest="cont", action="store_true", help=text)

    text = """Path to the directory to store the results at."""
    arg = subpars.add_argument("-o", "--outdir", type=Path, help=text)
    if argcomplete:
        arg.completer = argcomplete.completers.DirectoriesCompleter()

    text = f"""Any string which may serve as an identifier of this run. By default report ID is "
               the current date, prefixed with the remote host name in case the '-H' option was
               used: [hostname-]YYYYMMDD. For example, "20150323" is a report ID for a run made on
               March 23, 2015. The allowed characters are: {REPORTID_CHARS_DESCR}."""
    subpars.add_argument("--reportid", help=text)

    text = f"""This tool works by scheduling a delayed interrupt, then sleeping and waiting for it
               to happen. This step is referred to as a "measurement cycle" and it is usually
               repeated many times. The launch distance defines how far in the future the delayed
               interrupt is scheduled. By default this tool randomly selects launch distance. Launch
               distance minimum and maximum values are specific to selected delayed event source.
               Specify a comma-separated range in microseconds (e.g '--ldist 5000,50000'), or a
               single value if you want launch distance to be precisely that value all the time. Too
               low values may cause failures or prevent the SUT from reaching deep C-states. Note,
               {OWN_NAME} does not control when the system enters in idle state. This option
               controls the launch distance, but the moment of entering the C-state can be anywhere
               between the moment of arming the delayed interrupt and the moment it fires."""
    subpars.add_argument("-l", "--ldist", help=text)

    text = """The logical CPU number to measure, default is CPU 0."""
    subpars.add_argument("--cpunum", help=text, type=int, default=0)

    text = f"""This option exists for debugging and troubleshooting purposes. Please, do not use
               for other reasons. While normally {OWN_NAME} kernel modules are unloaded after the
               measurements are done, with this option the modules will stay loaded into the
               kernel. Keep in mind that if the the specified 'devid' device was bound to some
               driver (e.g., a network driver), it will be unbinded and with this option it won't be
               binded back."""
    subpars.add_argument("--no-unload", action="store_true", help=text)

    text = """The post-measurement trigger. Please, provide path to an executable on the SUT that
              should be executed after a datapoint had been collected. The next measurement cycle
              will start only after the trigger program finishes. This option exists for debugging
              and troubleshooting purposes. Note, the specified program will be executed as
              'POST_TRIGGER --latency <value>', where '<value>' is the last observed wake latency
              in nanoseconds."""
    subpars.add_argument("--post-trigger", metavar="POST_TRIGGER", type=Path, help=text)

    text = """By default, the post trigger is executed for every datapoint, but this option allows
              for setting the wake latency trigger range - the trigger program will be executed
              only when observed latency is in the range (inclusive). Specify a comma-separated
              range in nanoseconds (e.g '--post-trigger-range 50000,60000')."""
    subpars.add_argument("--post-trigger-range", help=text)

    text = """Generate an HTML report for collected results (same as calling 'report' command with
              default arguments)."""
    subpars.add_argument("--report", action="store_true", help=text)

    text = f"""By default {OWN_NAME} does not accept network card as a measurement device if its
               Linux network interface is in an active state, such as "up". Use '--force' to disable
               this safety mechanism. Use '--force' option with caution."""
    subpars.add_argument("--force", action="store_true", help=text)

    text = """The ID of the device to use for measuring the latency. For example, it can be a PCI
              address of the Intel I210 device, or "tdt" for the TSC deadline timer block of the
              CPU. Use the 'scan' command to get supported devices."""
    subpars.add_argument("devid", help=text)

    #
    # Create parsers for the "report" command.
    #
    text = "Create an HTML report."
    descr = f"""Create an HTML report for one or multiple test results."""
    subpars = subparsers.add_parser("report", help=text, description=descr)
    subpars.set_defaults(func=report_command)

    text = f"""Path to the directory to store the report at. By default the report is stored in the
               '{OWN_NAME}-report-<reportid>' sub-directory of the current working directory, where
               '<reportid>' is report ID of {OWN_NAME} test result (the first one if there are
               multiple)."""
    subpars.add_argument("-o", "--outdir", type=Path, help=text)

    text = """The row filter, same as '--rfilt' in the 'filter' command."""
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = """The row selector, same as '--rsel' in the 'filter' command."""
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = """Even up datapoints count before generating the report. This option is useful when
              generating a report for many test results (a diff). If the test results contain
              different count of datapoints (rows count in the CSV file), the report histograms may
              look a little bit misleading. This option evens up datapoints count in the test
              results. It just finds the test result with the minimum count of datapoints and
              ignores the extra datapoints in the other test results."""
    subpars.add_argument("--even-up-dp-count", action="store_true", help=text, dest="even_dpcnt")

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to use on X-axes, default is '{get_axes_default("xaxes")}'. Use
               '--list-columns' to get the list of the available column names."""
    subpars.add_argument("-x", "--xaxes", help=text)

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to use on the Y-axes. If multiple CSV column names are specified
               for the X- or Y-axes, then the report will include all the X- and Y-axes combination.
               The default is '{get_axes_default("yaxes")}'. Use '--list-columns' to get the list of
               the available column names."""
    subpars.add_argument("-y", "--yaxes", help=text)

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to add a histogram for, default is '{get_axes_default("hist")}'.
               Use '--list-columns' to get the list of the available column names. Use value 'none'
               to disable histograms."""
    subpars.add_argument("--hist", help=text)

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to add a cumulative distribution for, default is
               '{get_axes_default("chist")}'. Use '--list-columns' to get the list of the available
               column names. Use value 'none' to disable cumulative histograms."""
    subpars.add_argument("--chist", help=text)

    text = """Every input raw result comes with a report ID. This report ID is basically a short
              name for the test result, and it used in the HTML report to refer to the test result.
              However, sometimes it is helpful to temporarily override the report IDs just for the
              HTML report, and this is what the '--reportids' option does. Please, specify a
              comma-separated list of report IDs for every input raw test result. The first report
              ID will be used for the first raw rest result, the second report ID will be used for
              the second raw test result, and so on. Please, refer to the '--reportid' option
              description in the 'start' command for more information about the report ID."""
    subpars.add_argument("--reportids", help=text)

    text = """The report title description - any text describing this report as whole, or path to a
              file containing the overall report description. For example, if the report compares
              platform A and platform B, the description could be something like 'platform A vs B
              comparison'. This text will be included into the very beginning of the resulting HTML
              report."""
    subpars.add_argument("--title-descr", help=text)

    text = f"""The generated report includes references to the test results. By default, these
               references are symlinks to the raw result directories. However, this makes the
               generated report be not relocatable. Use this option to make the report relocatable
               in expence of increased disk space consumption - this tool will make a copy of the
               test results."""
    subpars.add_argument("--relocatable", action="store_true", help=text)

    text = """Print the list of the available column names and exit."""
    subpars.add_argument("--list-columns", action="store_true", help=text)

    text = f"""One or multiple {OWN_NAME} test result paths."""
    subpars.add_argument("respaths", nargs="+", type=Path, help=text)

    #
    # Create parsers for the "filter" command.
    #
    text = "Filter datapoints out of a test result."
    descr = f"""Filter datapoints out of a test result by removing CSV rows and columns according to
                specified criteria. The criteria is specified using the row and column filter and
                selector options ('--rsel', '--cfilt', etc). The options may be specified multiple
                times."""
    subpars = subparsers.add_parser("filter", help=text, description=descr)
    subpars.set_defaults(func=ToolsCommon.filter_command)

    text = """The row filter: remove all the rows satisfying the filter expression. Here is an
              example of an expression: '(WakeLatency < 10000) | (PC6%% < 1)'. This row filter
              expression will remove all rows with 'WakeLatency' smaller than 10000 nanoseconds or
              package C6 residency smaller than 1%%. The detailed row filter expression syntax can
              be found in the documentation for the 'eval()' function of Python 'pandas' module. You
              can use column names in the expression, or the special word 'index' for the row
              number. Value '0' is the header, value '1' is the first row, and so on. For example,
              expression 'index >= 10' will get rid of all datarows except for the first 10 ones.
              """
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = """The row selector: remove all rows except for those satisfying the selector expression.
              In other words, the selector is just an inverse filter: '--rsel expr' is the same as
              '--rfilt "not (expr)"'."""
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = """The columns filter: remove all column specified in the filter. The columns filter is
              just a comma-separated list of the CSV file column names or python style regular
              expressions matching the names. For example expression 'SilentTime,WarmupDelay,.*Cyc',
              would remove columns 'SilentTime', 'WarmupDelay' and all columns with 'Cyc' in the
              column name. Use '--list-columns' to get the list of the available column names."""
    subpars.add_argument("--cfilt", action=ArgParse.OrderedArg, help=text)

    text = """The columns selector: remove all column except for those specified in the selector.
              The syntax is the same as for '--cfilt'."""
    subpars.add_argument("--csel", action=ArgParse.OrderedArg, help=text)

    text = """By default the resulting CSV lines are printed to the standard output. But this option
              can be used to specify the output directly to store the result at. This will create a
              filtered version of the input test result."""
    subpars.add_argument("-o", "--outdir", type=Path, help=text)

    text = """Print the list of the available column names and exit."""
    subpars.add_argument("--list-columns", action="store_true", help=text)

    text = """Report ID of the filtered version of the result (can only be used with '--outdir')."""
    subpars.add_argument("--reportid", help=text)

    text = f"""The {OWN_NAME} test result path to filter."""
    subpars.add_argument("respath", type=Path, help=text)

    #
    # Create parsers for the "stats" command.
    #
    text = f"Calculate statistics for a {OWN_NAME} test result."
    descr = f"""Calculates various statistics for a {OWN_NAME} test results and prints them."""
    subpars = subparsers.add_parser("stats", help=text, description=descr)
    subpars.set_defaults(func=ToolsCommon.stats_command)

    text = """The row filter, same as '--rfilt' in the 'filter' command."""
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = """The row selector, same as '--rsel' in the 'filter' command."""
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = """The column filter, same as '--cfilt' in the 'filter' command."""
    subpars.add_argument("--cfilt", action=ArgParse.OrderedArg, help=text)

    text = """The column selector, same as '--csel' in the 'filter' command."""
    subpars.add_argument("--csel", action=ArgParse.OrderedArg, help=text)

    text = """Comma-separated list of statistic functions to calculate. By default all generally
              interesting functions are calculated (each column name is associated with a list of
              functions that make sense for this column). Use '--list-funcs' to get the list of
              supported functions."""
    subpars.add_argument("-f", "--funcs", help=text)

    text = """Print the list of the available statistic functions."""
    subpars.add_argument("--list-funcs", action="store_true", help=text)

    text = f"""The {OWN_NAME} test result path to calculate statistics for."""
    subpars.add_argument("respath", type=Path, help=text)

    if argcomplete:
        argcomplete.autocomplete(parser)

    args = parser.parse_args()
    args.toolname = OWN_NAME
    args.minkver = "4.19-rc1"
    args.reportid_additional_chars = REPORTID_ADDITIONAL_CHARS

    return args

def warn_trace_printk(proc):
    """
    Kernels before v5.6 did not have in-kernel synthetic trace event creation capabilities, so in
    that case 'wult' driver uses 'trace_printk()' to deliver the measurement results. But this is a
    debugging capability and should not be used for anything else. For now, we support pre-5.6
    kernels and 'trace_printk()', but we would like to remove the support. This function warns the
    user about the upcoming change.
    """

    kver = KernelVersion.get_kver(proc=proc)
    if KernelVersion.kver_lt(kver, "5.6"):
        LOG.warning("version of the kernel%s is %s, and soon it won't be supported.\nPlease, " \
                    "switch to kernel version 5.6 or newer.", proc.hostmsg, kver)

def start_command(args):
    """Implements the 'start' command."""

    if args.post_trigger_range and not args.post_trigger:
        raise Error("specify post trigger program to run")

    proc = ToolsCommon.get_proc(args, args.hostname)

    warn_trace_printk(proc)

    if ToolsCommon.is_deploy_needed(proc, OWN_NAME):
        msg = f"'{OWN_NAME}' drivers are not up-to-date{proc.hostmsg}', " \
              f"please run: {OWN_NAME} deploy"
        if proc.is_remote:
            msg += f" -H {proc.hostname}"
        LOG.warning(msg)

    if not args.reportid and proc.is_remote:
        prefix = proc.hostname
    else:
        prefix = None
    args.reportid = ReportID.format_reportid(prefix=prefix, reportid=args.reportid,
                                             strftime=f"{OWN_NAME}-{args.devid}-%Y%m%d",
                                             additional_chars=REPORTID_ADDITIONAL_CHARS)

    if not args.outdir:
        args.outdir = Path(f"./{args.reportid}")

    with WORawResult.WultWORawResult(args.reportid, args.outdir, VERSION, args.cpunum,
                                     cont=args.cont) as res:
        # Configure the logger to print to both the console and the log file.
        try:
            res.logs_path.mkdir(exist_ok=True)
        except OSError as err:
            raise Error("cannot create log directory '{res.logs_path}': {err}")
        logfile = res.logs_path / "wult.log.txt"
        Logging.setup_logger(OWN_NAME, info_logfile=logfile, error_logfile=logfile)

        with WultRunner.WultRunner(proc, args.devid, res, args.ldist, args.force) as runner:
            runner.unload = not args.no_unload
            if args.post_trigger:
                runner.set_post_trigger(args.post_trigger, trange=args.post_trigger_range)
            runner.prepare()
            runner.run(dpcnt=args.dpcnt)

    if not args.report:
        return

    rsts = RORawResult.RORawResult(args.outdir)
    rep = WultHTMLReport.WultHTMLReport([rsts], args.outdir, title_descr=args.reportid)
    rep.relocatable = False
    rep.set_hover_colnames(HOVER_COLNAME_REGEXS)
    rep.generate()

def report_command(args):
    """Implements the 'report' command."""

    # Split the comma-separated lists.
    for name in ("xaxes", "yaxes", "hist", "chist"):
        val = getattr(args, name)
        if val:
            if val == "none":
                setattr(args, name, "")
            else:
                setattr(args, name, Trivial.split_csv_line(val))

    rsts = ToolsCommon.report_command_open_raw_results(args)

    if args.list_columns:
        return

    for res in rsts:
        ToolsCommon.apply_filters(args, res)

    if args.even_dpcnt:
        ToolsCommon.even_up_dpcnt(rsts)

    if args.outdir is None:
        args.outdir = ReportID.format_reportid(prefix=f"{OWN_NAME}-report",
                                               reportid=rsts[0].reportid,
                                               additional_chars=REPORTID_ADDITIONAL_CHARS)

    rep = WultHTMLReport.WultHTMLReport(rsts, args.outdir, title_descr=args.title_descr,
                                        xaxes=args.xaxes, yaxes=args.yaxes, hist=args.hist,
                                        chist=args.chist)
    rep.relocatable = args.relocatable
    rep.set_hover_colnames(HOVER_COLNAME_REGEXS)
    rep.generate()

def scan_command(args):
    """Implements the 'scan' command."""

    proc = ToolsCommon.get_proc(args, args.hostname)

    msg = ""
    for devid, alias, descr in Devices.scan_devices(proc):
        msg += f" * Device ID: {devid}\n"
        if alias:
            msg += f"   - Alias: {alias}\n"
        msg += f"   - Description: {descr}\n"

    if not msg:
        LOG.info("No %s compatible devices found", OWN_NAME)
        return

    LOG.info("Compatible device(s)%s:\n%s", proc.hostmsg, msg.rstrip())

def load_command(args):
    """Implements the 'load' command."""

    proc = ToolsCommon.get_proc(args, args.hostname)
    with EventsProvider.EventsProvider(args.devid, 0, proc, force=args.force) as ep:
        ep.unload = not args.no_unload
        ep.prepare()
        LOG.info("Loaded the '%s' wult delayed event driver", ep.dev.drvname)

def main():
    """Script entry point."""

    args = parse_arguments()

    if getattr(args, "func", None):
        args.func(args)
    else:
        LOG.error("please, run '%s -h' for help.", OWN_NAME)
        raise SystemExit(1)

    return 0

# The script entry point.
if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        LOG.info("Interrupted, exiting")
    except Error as err:
        LOG.error_out(err)
