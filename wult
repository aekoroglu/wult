#!/usr/bin/python3
#
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2019-2020 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

"""
wult - a tool for measuring C-state latency.
"""

import sys
import logging
from pathlib import Path

try:
    import argcomplete
except ImportError:
    # We can live without argcomplete, we only lose tab completions.
    argcomplete = None

from wultlibs.helperlibs import Logging, ArgParse, ReportID, Trivial, KernelVersion, Human
from wultlibs.helperlibs.Exceptions import Error
from wultlibs import ToolsCommon, Devices, EventsProvider, RORawResult, WultHTMLReport
from wultlibs import WultRunner, WORawResult

VERSION = "1.8.10"
OWN_NAME = "wult"

# By default 'ReportID' module does not allow for the ":" character, but it is part of the PCI
# address, and we allow for PCI addresses as device IDs. Here are few constants that we use to
# extend the default allowed report ID characters set.
REPORTID_ADDITIONAL_CHARS = ":"
REPORTID_CHARS_DESCR = ReportID.get_charset_descr(additional_chars=REPORTID_ADDITIONAL_CHARS)

# Regular expressions for the datapoint CSV file columns names that should show up in the hover
# text of the scatter plot. The middle element selects all the core and package C-state residency
# columns.
HOVER_COLNAME_REGEXS = [".*Latency", ".*Delay", "LDist", "ReqCState", r"(Derived)?[PC]C.+%"]

LOG = logging.getLogger()
Logging.setup_logger(OWN_NAME)

def get_axes_default(name):
    """Returns the default CSV column names for X- or Y-axes, as well as histograms."""

    names = getattr(WultHTMLReport, f"DEFAULT_{name.upper()}")
    # The result is used for argparse, which does not accept '%' symbols.
    return names.replace("%", "%%")

def parse_arguments():
    """A helper function which parses the input arguments."""

    text = sys.modules[__name__].__doc__
    parser = ArgParse.ArgsParser(description=text, prog=OWN_NAME, ver=VERSION)

    text = "Force coloring of the text output."
    parser.add_argument("--force-color", action="store_true", help=text)
    subparsers = parser.add_subparsers(title="commands", metavar="")
    subparsers.required = True

    #
    # Create parsers for the "deploy" command.
    #
    text = f"Compile and deploy {OWN_NAME} drivers."
    descr = f"""Compile and deploy {OWN_NAME} drivers on local or remote host. This command has many
                options, but they are very rarely useful and most probably you do not need them."""
    subpars = subparsers.add_parser("deploy", help=text, description=descr)
    ToolsCommon.add_deploy_cmdline_args(subpars, OWN_NAME, drivers=True, helpers=False,
                                        argcomplete=argcomplete)
    subpars.set_defaults(func=ToolsCommon.deploy_command)

    #
    # Create parsers for the "scan" command.
    #
    text = "Scan for device id."
    descr = """Scan for compatible device."""
    subpars = subparsers.add_parser("scan", help=text, description=descr)
    subpars.set_defaults(func=scan_command)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    #
    # Create parsers for the "load" command.
    #
    text = f"Load {OWN_NAME} drivers and exit."
    descr = f"""Load {OWN_NAME} drivers and exit without starting the measurements."""
    subpars = subparsers.add_parser("load", help=text, description=descr)
    subpars.set_defaults(func=load_command)

    text = """This command exists for debugging and troubleshooting purposes. Please, do not use for
              other reasons. keep in mind that if the the specified \'devid\' device was bound to
              some driver (e.g., a network driver), it will be unbinded and with this option It
              won't be binded back."""

    subpars.add_argument("--no-unload", action="store_true", help=text)

    text = f"""By default {OWN_NAME} refuses to load network card drivers if its Linux network
               interface is in an active state, such as "up". Use '--force' to disable this safety
               mechanism. Use '--force' option with caution."""
    subpars.add_argument("--force", action="store_true", help=text)

    text = "The device ID, same as in the 'start' command."""
    subpars.add_argument("devid", help=text)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    #
    # Create parsers for the "start" command.
    #
    text = "Start the measurements."
    descr = """Start measuring and recording C-state latency."""
    subpars = subparsers.add_parser("start", help=text, description=descr)
    subpars.set_defaults(func=start_command)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    text = """How many datapoints should the test result include, default is 1000000. Note, in case
              a pre-existing test result is continued (see '--continue'), the pre-existing
              datapoints are taken into account. For example, if the test result already has 6000
              datapoints and '-c 100000' is used, the tool will collect 4000 datapoints and exit.
              Warning: collecting too many datapoints may result in a very large test result file,
              which will be difficult to process later, because that would require a lot of
              memory."""
    subpars.add_argument("-c", "--datapoints", default=1000000, metavar="COUNT", dest="dpcnt",
                         help=text)

    text = """The measurement time limit, i.e., for how long the SUT should be measured. The default
              unit is minutes, but you can use 'h', 'm', and 's' to specify hours, minutes, and
              seconds. For example '1h25m' would be 1 hour and 25 minutes, or 10m5s would be ten
              minutes and 5 seconds. Value '0' means "no time limit", and this is the default. If
              this option is used along with the '--datapoints' option, then measurements will stop
              as when either the time limit is reached, or the required amount of datapoints is
              collected."""
    subpars.add_argument("--time-limit", dest="tlimit", metavar="LIMIT", help=text)

    text = """If the output directory already contains the datapoints CSV file, do not override it
              (default behavior), but continue appending more datapoints instead."""
    subpars.add_argument("--continue", dest="cont", action="store_true", help=text)

    text = """Path to the directory to store the results at."""
    arg = subpars.add_argument("-o", "--outdir", type=Path, help=text)
    if argcomplete:
        arg.completer = argcomplete.completers.DirectoriesCompleter()

    text = f"""Any string which may serve as an identifier of this run. By default report ID is "
               the current date, prefixed with the remote host name in case the '-H' option was
               used: [hostname-]YYYYMMDD. For example, "20150323" is a report ID for a run made on
               March 23, 2015. The allowed characters are: {REPORTID_CHARS_DESCR}."""
    subpars.add_argument("--reportid", help=text)

    text = f"""This tool works by scheduling a delayed event, then sleeping and waiting for it to
                happen. This step is referred to as a "measurement cycle" and it is usually repeated
                many times. The launch distance defines how far in the future the delayed event is
                sceduled. By default this tool randomly selects launch distance within a range. The
                default range is specific to selected delayed event source, but you can override it
                with this option. Specify a comma-separated range (e.g '--ldist 10,5000'), or a
                single value if you want launch distance to be precisely that value all the time.
                The default unit is microseconds, but you can use the following specifiers as well:
                {Human.DURATION_NS_SPECS_DESCR}. For example, '--ldist 10us,5ms' would be a
                [10,5000] microseconds range. Too small values may cause failures or prevent the SUT
                from reaching deep C-states. If the range starts with 0, the minimum possible launch
                distance value allowed by the delayed event source will be used. The optimal launch
                distance range is system-specific."""
    subpars.add_argument("-l", "--ldist", help=text)

    text = """The logical CPU number to measure, default is CPU 0."""
    subpars.add_argument("--cpunum", help=text, type=int, default=0)

    text = f"""This option exists for debugging and troubleshooting purposes. Please, do not use
               for other reasons. While normally {OWN_NAME} kernel modules are unloaded after the
               measurements are done, with this option the modules will stay loaded into the
               kernel. Keep in mind that if the the specified 'devid' device was bound to some
               driver (e.g., a network driver), it will be unbinded and with this option it won't be
               binded back."""
    subpars.add_argument("--no-unload", action="store_true", help=text)

    text = """The post-measurement trigger. Please, provide path to an executable on the SUT that
              should be executed after a datapoint had been collected. The next measurement cycle
              will start only after the trigger program finishes. This option exists for debugging
              and troubleshooting purposes. Note, the specified program will be executed as
              'POST_TRIGGER --latency <value>', where '<value>' is the last observed wake latency
              in nanoseconds."""
    subpars.add_argument("--post-trigger", metavar="POST_TRIGGER", type=Path, help=text)

    text = """By default, the post trigger is executed for every datapoint, but this option allows
              for setting the wake latency trigger range - the trigger program will be executed
              only when observed latency is in the range (inclusive). Specify a comma-separated
              range, e.g '--post-trigger-range 50,600'. The default unit is microseconds, but you
              can use the following specifiers as well: {Human.DURATION_NS_SPECS_DESCR}. For
              example, '--post-trigger-range 100us,1ms' would be a [100,1000] microseconds range."""
    subpars.add_argument("--post-trigger-range", metavar="TRANGE", dest="trange", help=text)

    text = """Generate an HTML report for collected results (same as calling 'report' command with
              default arguments)."""
    subpars.add_argument("--report", action="store_true", help=text)

    text = f"""By default {OWN_NAME} does not accept network card as a measurement device if its
               Linux network interface is in an active state, such as "up". Use '--force' to disable
               this safety mechanism. Use '--force' option with caution."""
    subpars.add_argument("--force", action="store_true", help=text)

    text = """The ID of the device to use for measuring the latency. For example, it can be a PCI
              address of the Intel I210 device, or "tdt" for the TSC deadline timer block of the
              CPU. Use the 'scan' command to get supported devices."""
    subpars.add_argument("devid", help=text)

    #
    # Create parsers for the "report" command.
    #
    text = "Create an HTML report."
    descr = f"""Create an HTML report for one or multiple test results."""
    subpars = subparsers.add_parser("report", help=text, description=descr)
    subpars.set_defaults(func=report_command)

    text = f"""Path to the directory to store the report at. By default the report is stored in the
               '{OWN_NAME}-report-<reportid>' sub-directory of the current working directory, where
               '<reportid>' is report ID of {OWN_NAME} test result (the first one if there are
               multiple)."""
    subpars.add_argument("-o", "--outdir", type=Path, help=text)

    text = ToolsCommon.RFILT_DESCR
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.RSEL_DESCR
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = """Even up datapoints count before generating the report. This option is useful when
              generating a report for many test results (a diff). If the test results contain
              different count of datapoints (rows count in the CSV file), the report histograms may
              look a little bit misleading. This option evens up datapoints count in the test
              results. It just finds the test result with the minimum count of datapoints and
              ignores the extra datapoints in the other test results."""
    subpars.add_argument("--even-up-dp-count", action="store_true", help=text, dest="even_dpcnt")

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to use on X-axes, default is '{get_axes_default("xaxes")}'. Use
               '--list-columns' to get the list of the available column names."""
    subpars.add_argument("-x", "--xaxes", help=text)

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to use on the Y-axes. If multiple CSV column names are specified
               for the X- or Y-axes, then the report will include all the X- and Y-axes combination.
               The default is '{get_axes_default("yaxes")}'. Use '--list-columns' to get the list of
               the available column names."""
    subpars.add_argument("-y", "--yaxes", help=text)

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to add a histogram for, default is '{get_axes_default("hist")}'.
               Use '--list-columns' to get the list of the available column names. Use value 'none'
               to disable histograms."""
    subpars.add_argument("--hist", help=text)

    text = f"""A comma-separated list of CSV column names (or python style regular expressions
               matching the names) to add a cumulative distribution for, default is
               '{get_axes_default("chist")}'. Use '--list-columns' to get the list of the available
               column names. Use value 'none' to disable cumulative histograms."""
    subpars.add_argument("--chist", help=text)

    text = """Every input raw result comes with a report ID. This report ID is basically a short
              name for the test result, and it used in the HTML report to refer to the test result.
              However, sometimes it is helpful to temporarily override the report IDs just for the
              HTML report, and this is what the '--reportids' option does. Please, specify a
              comma-separated list of report IDs for every input raw test result. The first report
              ID will be used for the first raw rest result, the second report ID will be used for
              the second raw test result, and so on. Please, refer to the '--reportid' option
              description in the 'start' command for more information about the report ID."""
    subpars.add_argument("--reportids", help=text)

    text = """The report title description - any text describing this report as whole, or path to a
              file containing the overall report description. For example, if the report compares
              platform A and platform B, the description could be something like 'platform A vs B
              comparison'. This text will be included into the very beginning of the resulting HTML
              report."""
    subpars.add_argument("--title-descr", help=text)

    text = f"""The generated report includes references to the test results. By default, these
               references are symlinks to the raw result directories. However, this makes the
               generated report be not relocatable. Use this option to make the report relocatable
               in expence of increased disk space consumption - this tool will make a copy of the
               test results."""
    subpars.add_argument("--relocatable", action="store_true", help=text)

    text = """Print the list of the available column names and exit."""
    subpars.add_argument("--list-columns", action="store_true", help=text)

    text = f"""One or multiple {OWN_NAME} test result paths."""
    subpars.add_argument("respaths", nargs="+", type=Path, help=text)

    #
    # Create parsers for the "filter" command.
    #
    text = "Filter datapoints out of a test result."
    descr = ToolsCommon.FILT_DESCR
    subpars = subparsers.add_parser("filter", help=text, description=descr)
    subpars.set_defaults(func=ToolsCommon.filter_command)

    text = ToolsCommon.RFILT_DESCR
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.RSEL_DESCR
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CFILT_DESCR
    subpars.add_argument("--cfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CSEL_DESCR
    subpars.add_argument("--csel", action=ArgParse.OrderedArg, help=text)

    text = """By default the resulting CSV lines are printed to the standard output. But this option
              can be used to specify the output directly to store the result at. This will create a
              filtered version of the input test result."""
    subpars.add_argument("-o", "--outdir", type=Path, help=text)

    text = """Print the list of the available column names and exit."""
    subpars.add_argument("--list-columns", action="store_true", help=text)

    text = """Report ID of the filtered version of the result (can only be used with '--outdir')."""
    subpars.add_argument("--reportid", help=text)

    text = f"""The {OWN_NAME} test result path to filter."""
    subpars.add_argument("respath", type=Path, help=text)

    #
    # Create parsers for the "calc" command.
    #
    text = f"Calculate summary functions for a {OWN_NAME} test result."
    descr = f"""Calculates various summary functions for a {OWN_NAME} test result (e.g., the median
                value for one of the CSV columns)."""
    subpars = subparsers.add_parser("calc", help=text, description=descr)
    subpars.set_defaults(func=ToolsCommon.calc_command)

    text = ToolsCommon.RFILT_DESCR
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.RSEL_DESCR
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CFILT_DESCR
    subpars.add_argument("--cfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CSEL_DESCR
    subpars.add_argument("--csel", action=ArgParse.OrderedArg, help=text)

    text = """Comma-separated list of summary functions to calculate. By default all generally
              interesting functions are calculated (each column name is associated with a list of
              functions that make sense for this column). Use '--list-funcs' to get the list of
              supported functions."""
    subpars.add_argument("-f", "--funcs", help=text)

    text = """Print the list of the available summary functions."""
    subpars.add_argument("--list-funcs", action="store_true", help=text)

    text = f"""The {OWN_NAME} test result path to calculate summary functions for."""
    subpars.add_argument("respath", type=Path, help=text)

    if argcomplete:
        argcomplete.autocomplete(parser)

    args = parser.parse_args()
    args.toolname = OWN_NAME
    args.minkver = "4.19-rc1"
    args.reportid_additional_chars = REPORTID_ADDITIONAL_CHARS

    return args

def warn_trace_printk(proc):
    """
    Kernels before v5.6 did not have in-kernel synthetic trace event creation capabilities, so in
    that case 'wult' driver uses 'trace_printk()' to deliver the measurement results. But this is a
    debugging capability and should not be used for anything else. For now, we support pre-5.6
    kernels and 'trace_printk()', but we would like to remove the support. This function warns the
    user about the upcoming change.
    """

    kver = KernelVersion.get_kver(proc=proc)
    if KernelVersion.kver_lt(kver, "5.6"):
        LOG.warning("version of the kernel%s is %s, and soon it won't be supported.\nPlease, " \
                    "switch to kernel version 5.6 or newer.", proc.hostmsg, kver)

def start_command(args):
    """Implements the 'start' command."""

    if args.trange and not args.post_trigger:
        raise Error("specify post trigger program to run")

    proc = ToolsCommon.get_proc(args, args.hostname)

    warn_trace_printk(proc)

    if ToolsCommon.is_deploy_needed(proc, OWN_NAME):
        msg = f"'{OWN_NAME}' drivers are not up-to-date{proc.hostmsg}', " \
              f"please run: {OWN_NAME} deploy"
        if proc.is_remote:
            msg += f" -H {proc.hostname}"
        LOG.warning(msg)

    if not args.reportid and proc.is_remote:
        prefix = proc.hostname
    else:
        prefix = None
    args.reportid = ReportID.format_reportid(prefix=prefix, reportid=args.reportid,
                                             strftime=f"{OWN_NAME}-{args.devid}-%Y%m%d",
                                             additional_chars=REPORTID_ADDITIONAL_CHARS)

    if not args.outdir:
        args.outdir = Path(f"./{args.reportid}")
    if args.tlimit:
        args.tlimit = Human.parse_duration(args.tlimit, default_unit="m")
    if args.ldist:
        args.ldist = ToolsCommon.validate_ldist(args.ldist)
    args.cpunum = ToolsCommon.validate_cpunum(args.cpunum, proc=proc)
    if args.trange:
        args.trange = ToolsCommon.validate_trange(args.trange)

    with WORawResult.WultWORawResult(args.reportid, args.outdir, VERSION, args.cpunum,
                                     cont=args.cont) as res:
        # Configure the logger to print to both the console and the log file.
        try:
            res.logs_path.mkdir(exist_ok=True)
        except OSError as err:
            raise Error(f"cannot create log directory '{res.logs_path}': {err}")
        logfile = res.logs_path / f"{OWN_NAME}.log.txt"
        Logging.setup_logger(OWN_NAME, info_logfile=logfile, error_logfile=logfile)

        with WultRunner.WultRunner(proc, args.devid, res, args.ldist, args.force) as runner:
            runner.unload = not args.no_unload
            if args.post_trigger:
                runner.set_post_trigger(args.post_trigger, trange=args.trange)
            runner.prepare()
            runner.run(dpcnt=args.dpcnt, tlimit=args.tlimit)

    if not args.report:
        return

    rsts = RORawResult.RORawResult(args.outdir)
    rep = WultHTMLReport.WultHTMLReport([rsts], args.outdir, title_descr=args.reportid)
    rep.relocatable = False
    rep.set_hover_colnames(HOVER_COLNAME_REGEXS)
    rep.generate()

def report_command(args):
    """Implements the 'report' command."""

    # Split the comma-separated lists.
    for name in ("xaxes", "yaxes", "hist", "chist"):
        val = getattr(args, name)
        if val:
            if val == "none":
                setattr(args, name, "")
            else:
                setattr(args, name, Trivial.split_csv_line(val))

    rsts = ToolsCommon.report_command_open_raw_results(args)

    if args.list_columns:
        return

    for res in rsts:
        ToolsCommon.apply_filters(args, res)

    if args.even_dpcnt:
        ToolsCommon.even_up_dpcnt(rsts)

    if args.outdir is None:
        args.outdir = ReportID.format_reportid(prefix=f"{OWN_NAME}-report",
                                               reportid=rsts[0].reportid,
                                               additional_chars=REPORTID_ADDITIONAL_CHARS)

    rep = WultHTMLReport.WultHTMLReport(rsts, args.outdir, title_descr=args.title_descr,
                                        xaxes=args.xaxes, yaxes=args.yaxes, hist=args.hist,
                                        chist=args.chist)
    rep.relocatable = args.relocatable
    rep.set_hover_colnames(HOVER_COLNAME_REGEXS)
    rep.generate()

def scan_command(args):
    """Implements the 'scan' command."""

    proc = ToolsCommon.get_proc(args, args.hostname)

    msg = ""
    for devid, alias, descr in Devices.scan_devices(proc):
        msg += f" * Device ID: {devid}\n"
        if alias:
            msg += f"   - Alias: {alias}\n"
        msg += f"   - Description: {descr}\n"

    if not msg:
        LOG.info("No %s compatible devices found", OWN_NAME)
        return

    LOG.info("Compatible device(s)%s:\n%s", proc.hostmsg, msg.rstrip())

def load_command(args):
    """Implements the 'load' command."""

    proc = ToolsCommon.get_proc(args, args.hostname)
    with EventsProvider.EventsProvider(args.devid, 0, proc, force=args.force) as ep:
        ep.unload = not args.no_unload
        ep.prepare()
        LOG.info("Loaded the '%s' %s delayed event driver", ep.dev.drvname, OWN_NAME)

def main():
    """Script entry point."""

    args = parse_arguments()

    if getattr(args, "func", None):
        args.func(args)
    else:
        LOG.error("please, run '%s -h' for help.", OWN_NAME)
        raise SystemExit(1)

    return 0

# The script entry point.
if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        LOG.info("Interrupted, exiting")
    except Error as err:
        LOG.error_out(err)
