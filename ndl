#!/usr/bin/python3
#
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 tw=100 et ai si
#
# Copyright (C) 2019-2020 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
#
# Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

"""ndl - a tool for measuring memory access latency observed by a network card."""

import sys
import logging
from pathlib import Path

try:
    import argcomplete
except ImportError:
    # We can live without argcomplete, we only lose tab completions.
    argcomplete = None

from wultlibs import ToolsCommon, NdlHTMLReport, NdlRunner, RORawResult, WORawResult
from wultlibs.helperlibs import Logging, ArgParse, ReportID, Human
from wultlibs.helperlibs.Exceptions import Error

VERSION = "1.3.6"
OWN_NAME = "ndl"

LOG = logging.getLogger()
Logging.setup_logger(OWN_NAME)

def parse_arguments():
    """A helper function which parses the input arguments."""

    text = sys.modules[__name__].__doc__
    parser = ArgParse.ArgsParser(description=text, prog=OWN_NAME, ver=VERSION)

    text = "Force coloring of the text output."
    parser.add_argument("--force-color", action="store_true", help=text)
    subparsers = parser.add_subparsers(title="commands", metavar="")
    subparsers.required = True

    #
    # Create parsers for the "deploy" command.
    #
    text = f"Compile and deploy {OWN_NAME} tools and drivers."
    descr = """Compile and deploy {OWN_NAME} drivers and helpers on local or remote host. This
               command has many options, but they are very rarely useful and most probably you do
               not need them."""
    subpars = subparsers.add_parser("deploy", help=text, description=descr)
    ToolsCommon.add_deploy_cmdline_args(subpars, OWN_NAME, drivers=True, helpers=True,
                                        argcomplete=argcomplete)
    subpars.set_defaults(func=ToolsCommon.deploy_command)

    #
    # Create parsers for the "start" command.
    #
    text = "Start the measurements."
    descr = """Start measuring and recording the latency data."""
    subpars = subparsers.add_parser("start", help=text, description=descr)
    subpars.set_defaults(func=start_command)

    ToolsCommon.add_ssh_options(subpars, argcomplete)

    text = f"""Path to {OWN_NAME} helper tools. The default is the path defined by the
               {OWN_NAME.upper()}_HELPERSPATH environment variable. If it is not defined, the
               default path is '$HOME/{ToolsCommon.HELPERS_LOCAL_DIR}/bin', where '$HOME' is home
               directory path of the 'USERNAME' user on the 'HOSTNAME' system (see '--host' and
               '--username' options)."""
    arg = subpars.add_argument("--helpers-path", metavar="HELPERSPATH", type=Path, help=text)
    if argcomplete:
        arg.completer = argcomplete.completers.DirectoriesCompleter()

    text = """How many datapoints should the test result include, default is 1000000. Note, in case
              a pre-existing test result is continued (see '--continue'), the pre-existing
              datapoints are taken into account. For example, if the test result already has 6000
              datapoints and '-c 10000' is used, the tool will collect 4000 datapoints and exit.
              Warning: collecting too many datapoints may result in a very large test result file,
              which will be difficult to process later, because that would require a lot of
              memory."""
    subpars.add_argument("-c", "--datapoints", default=1000000, metavar="COUNT", dest="dpcnt",
                         help=text)

    text = f"""The measurement time limit, i.e., for how long the SUT should be measured. The
               default unit is minutes, but you can use the following handy specifiers as well:
               {Human.DURATION_SPECS_DESCR}. For example '1h25m' would be 1 hour and 25 minutes, or
               10m5s would be 10 minutes and 5 seconds. Value '0' means "no time limit", and this is
               the default. If this option is used along with the '--datapoints' option, then
               measurements will stop as when either the time limit is reached, or the required
               amount of datapoints is collected."""
    subpars.add_argument("--time-limit", dest="tlimit", metavar="LIMIT", help=text)

    text = """If the output directory already contains the datapoints CSV file, do not override it
              (default behavior), but continue appending more datapoints instead."""
    subpars.add_argument("--continue", dest="cont", action="store_true", help=text)

    text = """Path to the directory to store the results at."""
    arg = subpars.add_argument("-o", "--outdir", type=Path, help=text)
    if argcomplete:
        arg.completer = argcomplete.completers.DirectoriesCompleter()

    text = f"""Any string which may serve as an identifier of this run. By default report ID is "
               the current date, prefixed with the remote host name in case the '-H' option was
               used: [hostname-]YYYYMMDD. For example, "20150323" is a report ID for a run made on
               March 23, 2015. The allowed characters are: {ReportID.get_charset_descr()}."""
    subpars.add_argument("--reportid", help=text)

    text = """The launch distance in microseconds. This tool works by scheduling a delayed network
              packet, then sleeping and waiting for the packet to be sent. This step is referred to
              as a "measurement cycle" and it is usually repeated many times. The launch distance
              defines how far in the future the delayed network packets are scheduled. By
              default this tool randomly selects launch distance in range of [5000, 50000] us (same
              as '--ldist 5000,50000'). Specify a comma-separated range or a single value if you want
              launch distance to be precisely that value all the time. Note, too low values may
              cause failures or prevent the SUT from reaching deep C-states. The optimal value is
              system-specific."""
    subpars.add_argument("-l", "--ldist", default="5000,50000", help=text)

    text = """The post-measurement trigger. Please, provide path to an executable on the SUT that
              should be executed after a datapoint had been collected. The next measurement cycle
              will start only after the trigger program finishes. This option exists for debugging
              and troubleshooting purposes. Note, the specified program will be executed as
              'POST_TRIGGER --latency <value>', where '<value>' is the last observed RTD in
              nanoseconds."""
    subpars.add_argument("--post-trigger", metavar="POST_TRIGGER", type=Path, help=text)

    text = """By default, the post trigger is executed for every datapoint, but this option allows
              for setting the RTD threshold - the trigger program will be executed only when latency
              exceeds the threshold. The threshold should be an integer amount of nanoseconds."""
    subpars.add_argument("--post-trigger-threshold", help=text)

    text = """Generate an HTML report for collected results (same as calling 'report' command with
              default arguments)."""
    subpars.add_argument("--report", action="store_true", help=text)

    text = """The network interface backed by the NIC to use for latency measurements. Today only
              Intel I210 and I211 NICs are supported. Please, specify NIC's network interface name
              (e.g., eth0)."""
    subpars.add_argument("ifname", help=text)

    #
    # Create parsers for the "report" command.
    #
    text = "Create an HTML report."
    descr = f"""Create an HTML report for one or multiple test results."""
    subpars = subparsers.add_parser("report", help=text, description=descr)
    subpars.set_defaults(func=report_command)

    text = f"""Path to the directory to store the report at. By default the report is stored in the
               '{OWN_NAME}-report-<reportid>' sub-directory of the current working directory, where
               '<reportid>' is report ID of {OWN_NAME} test result (the first one if there are
               multiple)."""
    subpars.add_argument("-o", "--outdir", type=Path, help=text)

    text = ToolsCommon.RFILT_DESCR
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = """The row selector, same as '--rsel' in the 'filter' command."""
    text = ToolsCommon.RSEL_DESCR

    text = """Even up datapoints count before generating the report. This option is useful when
              generating a report for many test results (a diff). If the test results contain
              different count of datapoints (rows count in the CSV file), the resulting histograms
              may look a little bit misleading. This option evens up datapoints count in the test
              results. It just finds the test result with the minimum count of datapoints and
              ignores the extra datapoints in the other test results."""
    subpars.add_argument("--even-up-dp-count", action="store_true", help=text, dest="even_dpcnt")

    text = """Every input raw result comes with a report ID. This report ID is basically a short
              name for the test result, and it used in the HTML report to refer to the test result.
              However, sometimes it is helpful to temporarily override the report IDs just for the
              HTML report, and this is what the '--reportids' option does. Please, specify a
              comma-separated list of report IDs for every input raw test result. The first report
              ID will be used for the first raw rest result, the second report ID will be used for
              the second raw test result, and so on. Please, refer to the '--reportid' option
              description in the 'start' command for more information about the report ID."""
    subpars.add_argument("--reportids", help=text)

    text = """The report title description - any text describing this report as whole, or path to a
              file containing the overall report description. For example, if the report compares
              platform A and platform B, the description could be something like 'platform A vs B
              comparison'. This text will be included into the very beginning of the resulting HTML
              report."""
    subpars.add_argument("--title-descr", help=text)

    text = f"""The generated report includes references to the test results. By default, these
               references are symlinks to the raw result directories. However, this makes the
               generated report be not relocatable. Use this option to make the report relocatable
               in expence of increased disk space consumption - this tool will make a copy of the
               test results."""
    subpars.add_argument("--relocatable", action="store_true", help=text)

    text = """Print the list of the available column names and exit."""
    subpars.add_argument("--list-columns", action="store_true", help=text)

    text = f"""{OWN_NAME} test result path to create the report for."""
    subpars.add_argument("respaths", nargs="+", type=Path, help=text)

    #
    # Create parsers for the "filter" command.
    #
    text = "Filter datapoints out of a test result."
    descr = ToolsCommon.FILT_DESCR
    subpars = subparsers.add_parser("filter", help=text, description=descr)
    subpars.set_defaults(func=ToolsCommon.filter_command)

    text = ToolsCommon.RFILT_DESCR
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.RSEL_DESCR
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CFILT_DESCR
    subpars.add_argument("--cfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CSEL_DESCR
    subpars.add_argument("--csel", action=ArgParse.OrderedArg, help=text)

    text = """By default the resulting CSV lines are printed to the standard output. But this option
              can be used to specify the output directly to store the result at. This will create a
              filtered version of the input test result."""
    subpars.add_argument("-o", "--outdir", type=Path, help=text)

    text = "Print the list of the available column names and exit."
    subpars.add_argument("--list-columns", action="store_true", help=text)

    text = f"Report ID of the filtered version of the result (can only be used with '--outdir')."
    subpars.add_argument("--reportid", help=text)

    text = f"The {OWN_NAME} test result path to filter."
    subpars.add_argument("respath", type=Path, help=text)

    #
    # Create parsers for the "calc" command.
    #
    text = f"Calculate summary functions for a {OWN_NAME} test result."
    descr = f"""Calculates various summary functions for a {OWN_NAME} test result (e.g., the median
                value for one of the CSV columns)."""
    subpars = subparsers.add_parser("calc", help=text, description=descr)
    subpars.set_defaults(func=ToolsCommon.calc_command)

    text = ToolsCommon.RFILT_DESCR
    subpars.add_argument("--rfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.RSEL_DESCR
    subpars.add_argument("--rsel", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CFILT_DESCR
    subpars.add_argument("--cfilt", action=ArgParse.OrderedArg, help=text)

    text = ToolsCommon.CSEL_DESCR
    subpars.add_argument("--csel", action=ArgParse.OrderedArg, help=text)

    text = """Comma-separated list of summary functions to calculate. By default all generally
              interesting functions are calculated (each column name is associated with a list of
              functions that make sense for this column). Use '--list-funcs' to get the list of
              supported functions."""
    subpars.add_argument("-f", "--funcs", help=text)

    text = """Print the list of the available summary functions."""
    subpars.add_argument("--list-funcs", action="store_true", help=text)

    text = f"""The {OWN_NAME} test result path to calculate summary functions for."""
    subpars.add_argument("respath", type=Path, help=text)

    if argcomplete:
        argcomplete.autocomplete(parser)

    args = parser.parse_args()
    args.toolname = OWN_NAME
    args.minkver = "5.1-rc1"

    return args

def start_command(args):
    """Implements the 'start' command."""

    if args.post_trigger_threshold and not args.post_trigger:
        raise Error("specify post trigger program to run")

    proc = ToolsCommon.get_proc(args, args.hostname)

    if not args.reportid and proc.is_remote:
        prefix = proc.hostname
    else:
        prefix = None
    args.reportid = ReportID.format_reportid(prefix=prefix, reportid=args.reportid,
                                             strftime=f"{OWN_NAME}-%Y%m%d")

    if not args.outdir:
        args.outdir = Path(f"./{args.reportid}")
    if args.tlimit:
        args.tlimit = Human.parse_duration(args.tlimit, default_unit="m")

    # Figure out the helper path.
    if not args.helpers_path:
        args.helpers_path = ToolsCommon.get_helpers_deploy_path(proc, OWN_NAME) / "bin"

    ndlrunner_bin = args.helpers_path / "ndlrunner"

    if ToolsCommon.is_deploy_needed(proc, OWN_NAME, helperpath=ndlrunner_bin):
        msg = f"'{OWN_NAME}' helpers and/or drivers are not up-to-date{proc.hostmsg}, " \
              f"please run: {OWN_NAME} deploy"
        if proc.is_remote:
            msg += f" -H {proc.hostname}"
        LOG.warning(msg)

    with WORawResult.NdlWORawResult(args.reportid, args.outdir, VERSION, cont=args.cont) as res:
        # Configure the logger to print to both the console and the log file.
        try:
            res.logs_path.mkdir(exist_ok=True)
        except OSError as err:
            raise Error(f"cannot create log directory '{res.logs_path}': {err}")
        logfile = res.logs_path / "wult.log.txt"
        Logging.setup_logger(OWN_NAME, info_logfile=logfile, error_logfile=logfile)

        with NdlRunner.NdlRunner(proc, args.ifname, res, ndlrunner_bin,
                                 ldist=args.ldist) as runner:
            runner.prepare()
            if args.post_trigger:
                runner.set_post_trigger(args.post_trigger, thresh=args.post_trigger_threshold)
            runner.run(dpcnt=args.dpcnt, tlimit=args.tlimit)

    if not args.report:
        return

    rsts = RORawResult.RORawResult(args.outdir)
    rep = NdlHTMLReport.NdlHTMLReport([rsts], args.outdir, title_descr=args.reportid)
    rep.relocatable = False
    rep.generate()

def report_command(args):
    """Implements the 'report' command."""

    rsts = ToolsCommon.report_command_open_raw_results(args)

    if args.list_columns:
        return

    for res in rsts:
        ToolsCommon.apply_filters(args, res)

    if args.even_dpcnt:
        ToolsCommon.even_up_dpcnt(rsts)

    if args.outdir is None:
        args.outdir = ReportID.format_reportid(prefix=f"{OWN_NAME}-report",
                                               reportid=rsts[0].reportid)

    rep = NdlHTMLReport.NdlHTMLReport(rsts, args.outdir, title_descr=args.title_descr)
    rep.relocatable = args.relocatable
    rep.generate()

def main():
    """Script entry point."""

    args = parse_arguments()

    if getattr(args, "func", None):
        args.func(args)
    else:
        LOG.error("please, run '%s -h' for help.", OWN_NAME)
        raise SystemExit(1)

    return 0

# The script entry point.
if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        LOG.info("\nInterrupted, exiting")
    except Error as err:
        LOG.error_out(err)
